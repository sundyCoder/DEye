// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/worker.proto

#ifndef PROTOBUF_tensorflow_2fcore_2fprotobuf_2fworker_2eproto__INCLUDED
#define PROTOBUF_tensorflow_2fcore_2fprotobuf_2fworker_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "tensorflow/core/framework/cost_graph.pb.h"
#include "tensorflow/core/framework/step_stats.pb.h"
#include "tensorflow/core/framework/device_attributes.pb.h"
#include "tensorflow/core/framework/graph.pb.h"
#include "tensorflow/core/framework/tensor.pb.h"
#include "tensorflow/core/protobuf/config.pb.h"
#include "tensorflow/core/protobuf/debug.pb.h"
#include "tensorflow/core/protobuf/named_tensor.pb.h"
#include "tensorflow/core/protobuf/tensorflow_server.pb.h"
// @@protoc_insertion_point(includes)

namespace tensorflow {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
void protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

class CleanupAllRequest;
class CleanupAllResponse;
class CleanupGraphRequest;
class CleanupGraphResponse;
class CreateWorkerSessionRequest;
class CreateWorkerSessionResponse;
class DeregisterGraphRequest;
class DeregisterGraphResponse;
class ExecutorOpts;
class GetStatusRequest;
class GetStatusResponse;
class LabeledStepStats;
class LoggingRequest;
class LoggingResponse;
class RecvTensorRequest;
class RecvTensorResponse;
class RegisterGraphRequest;
class RegisterGraphResponse;
class RunGraphRequest;
class RunGraphResponse;
class TraceOpts;
class TracingRequest;
class TracingResponse;

// ===================================================================

class GetStatusRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.GetStatusRequest) */ {
 public:
  GetStatusRequest();
  virtual ~GetStatusRequest();

  GetStatusRequest(const GetStatusRequest& from);

  inline GetStatusRequest& operator=(const GetStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStatusRequest& default_instance();

  static const GetStatusRequest* internal_default_instance();

  void UnsafeArenaSwap(GetStatusRequest* other);
  void Swap(GetStatusRequest* other);

  // implements Message ----------------------------------------------

  inline GetStatusRequest* New() const { return New(NULL); }

  GetStatusRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStatusRequest& from);
  void MergeFrom(const GetStatusRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetStatusRequest* other);
  void UnsafeMergeFrom(const GetStatusRequest& from);
  protected:
  explicit GetStatusRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.GetStatusRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<GetStatusRequest> GetStatusRequest_default_instance_;

// -------------------------------------------------------------------

class GetStatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.GetStatusResponse) */ {
 public:
  GetStatusResponse();
  virtual ~GetStatusResponse();

  GetStatusResponse(const GetStatusResponse& from);

  inline GetStatusResponse& operator=(const GetStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStatusResponse& default_instance();

  static const GetStatusResponse* internal_default_instance();

  void UnsafeArenaSwap(GetStatusResponse* other);
  void Swap(GetStatusResponse* other);

  // implements Message ----------------------------------------------

  inline GetStatusResponse* New() const { return New(NULL); }

  GetStatusResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStatusResponse& from);
  void MergeFrom(const GetStatusResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetStatusResponse* other);
  void UnsafeMergeFrom(const GetStatusResponse& from);
  protected:
  explicit GetStatusResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.DeviceAttributes device_attributes = 1;
  int device_attributes_size() const;
  void clear_device_attributes();
  static const int kDeviceAttributesFieldNumber = 1;
  const ::tensorflow::DeviceAttributes& device_attributes(int index) const;
  ::tensorflow::DeviceAttributes* mutable_device_attributes(int index);
  ::tensorflow::DeviceAttributes* add_device_attributes();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
      mutable_device_attributes();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
      device_attributes() const;

  // @@protoc_insertion_point(class_scope:tensorflow.GetStatusResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes > device_attributes_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<GetStatusResponse> GetStatusResponse_default_instance_;

// -------------------------------------------------------------------

class CreateWorkerSessionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CreateWorkerSessionRequest) */ {
 public:
  CreateWorkerSessionRequest();
  virtual ~CreateWorkerSessionRequest();

  CreateWorkerSessionRequest(const CreateWorkerSessionRequest& from);

  inline CreateWorkerSessionRequest& operator=(const CreateWorkerSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateWorkerSessionRequest& default_instance();

  static const CreateWorkerSessionRequest* internal_default_instance();

  void UnsafeArenaSwap(CreateWorkerSessionRequest* other);
  void Swap(CreateWorkerSessionRequest* other);

  // implements Message ----------------------------------------------

  inline CreateWorkerSessionRequest* New() const { return New(NULL); }

  CreateWorkerSessionRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateWorkerSessionRequest& from);
  void MergeFrom(const CreateWorkerSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateWorkerSessionRequest* other);
  void UnsafeMergeFrom(const CreateWorkerSessionRequest& from);
  protected:
  explicit CreateWorkerSessionRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_handle = 1;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 1;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);
  ::std::string* unsafe_arena_release_session_handle();
  void unsafe_arena_set_allocated_session_handle(
      ::std::string* session_handle);

  // optional .tensorflow.ServerDef server_def = 2;
  bool has_server_def() const;
  void clear_server_def();
  static const int kServerDefFieldNumber = 2;
  private:
  void _slow_mutable_server_def();
  void _slow_set_allocated_server_def(
      ::google::protobuf::Arena* message_arena, ::tensorflow::ServerDef** server_def);
  ::tensorflow::ServerDef* _slow_release_server_def();
  public:
  const ::tensorflow::ServerDef& server_def() const;
  ::tensorflow::ServerDef* mutable_server_def();
  ::tensorflow::ServerDef* release_server_def();
  void set_allocated_server_def(::tensorflow::ServerDef* server_def);
  ::tensorflow::ServerDef* unsafe_arena_release_server_def();
  void unsafe_arena_set_allocated_server_def(
      ::tensorflow::ServerDef* server_def);

  // @@protoc_insertion_point(class_scope:tensorflow.CreateWorkerSessionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  ::tensorflow::ServerDef* server_def_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CreateWorkerSessionRequest> CreateWorkerSessionRequest_default_instance_;

// -------------------------------------------------------------------

class CreateWorkerSessionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CreateWorkerSessionResponse) */ {
 public:
  CreateWorkerSessionResponse();
  virtual ~CreateWorkerSessionResponse();

  CreateWorkerSessionResponse(const CreateWorkerSessionResponse& from);

  inline CreateWorkerSessionResponse& operator=(const CreateWorkerSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateWorkerSessionResponse& default_instance();

  static const CreateWorkerSessionResponse* internal_default_instance();

  void UnsafeArenaSwap(CreateWorkerSessionResponse* other);
  void Swap(CreateWorkerSessionResponse* other);

  // implements Message ----------------------------------------------

  inline CreateWorkerSessionResponse* New() const { return New(NULL); }

  CreateWorkerSessionResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateWorkerSessionResponse& from);
  void MergeFrom(const CreateWorkerSessionResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateWorkerSessionResponse* other);
  void UnsafeMergeFrom(const CreateWorkerSessionResponse& from);
  protected:
  explicit CreateWorkerSessionResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.CreateWorkerSessionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CreateWorkerSessionResponse> CreateWorkerSessionResponse_default_instance_;

// -------------------------------------------------------------------

class RegisterGraphRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.RegisterGraphRequest) */ {
 public:
  RegisterGraphRequest();
  virtual ~RegisterGraphRequest();

  RegisterGraphRequest(const RegisterGraphRequest& from);

  inline RegisterGraphRequest& operator=(const RegisterGraphRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterGraphRequest& default_instance();

  static const RegisterGraphRequest* internal_default_instance();

  void UnsafeArenaSwap(RegisterGraphRequest* other);
  void Swap(RegisterGraphRequest* other);

  // implements Message ----------------------------------------------

  inline RegisterGraphRequest* New() const { return New(NULL); }

  RegisterGraphRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterGraphRequest& from);
  void MergeFrom(const RegisterGraphRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterGraphRequest* other);
  void UnsafeMergeFrom(const RegisterGraphRequest& from);
  protected:
  explicit RegisterGraphRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_handle = 1;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 1;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);
  ::std::string* unsafe_arena_release_session_handle();
  void unsafe_arena_set_allocated_session_handle(
      ::std::string* session_handle);

  // optional .tensorflow.GraphDef graph_def = 2;
  bool has_graph_def() const;
  void clear_graph_def();
  static const int kGraphDefFieldNumber = 2;
  private:
  void _slow_mutable_graph_def();
  void _slow_set_allocated_graph_def(
      ::google::protobuf::Arena* message_arena, ::tensorflow::GraphDef** graph_def);
  ::tensorflow::GraphDef* _slow_release_graph_def();
  public:
  const ::tensorflow::GraphDef& graph_def() const;
  ::tensorflow::GraphDef* mutable_graph_def();
  ::tensorflow::GraphDef* release_graph_def();
  void set_allocated_graph_def(::tensorflow::GraphDef* graph_def);
  ::tensorflow::GraphDef* unsafe_arena_release_graph_def();
  void unsafe_arena_set_allocated_graph_def(
      ::tensorflow::GraphDef* graph_def);

  // optional bool has_control_flow = 3 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_has_control_flow();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kHasControlFlowFieldNumber = 3;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_control_flow() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_has_control_flow(bool value);

  // optional .tensorflow.GraphOptions graph_options = 4;
  bool has_graph_options() const;
  void clear_graph_options();
  static const int kGraphOptionsFieldNumber = 4;
  private:
  void _slow_mutable_graph_options();
  void _slow_set_allocated_graph_options(
      ::google::protobuf::Arena* message_arena, ::tensorflow::GraphOptions** graph_options);
  ::tensorflow::GraphOptions* _slow_release_graph_options();
  public:
  const ::tensorflow::GraphOptions& graph_options() const;
  ::tensorflow::GraphOptions* mutable_graph_options();
  ::tensorflow::GraphOptions* release_graph_options();
  void set_allocated_graph_options(::tensorflow::GraphOptions* graph_options);
  ::tensorflow::GraphOptions* unsafe_arena_release_graph_options();
  void unsafe_arena_set_allocated_graph_options(
      ::tensorflow::GraphOptions* graph_options);

  // optional .tensorflow.DebugOptions debug_options = 5;
  bool has_debug_options() const;
  void clear_debug_options();
  static const int kDebugOptionsFieldNumber = 5;
  private:
  void _slow_mutable_debug_options();
  void _slow_set_allocated_debug_options(
      ::google::protobuf::Arena* message_arena, ::tensorflow::DebugOptions** debug_options);
  ::tensorflow::DebugOptions* _slow_release_debug_options();
  public:
  const ::tensorflow::DebugOptions& debug_options() const;
  ::tensorflow::DebugOptions* mutable_debug_options();
  ::tensorflow::DebugOptions* release_debug_options();
  void set_allocated_debug_options(::tensorflow::DebugOptions* debug_options);
  ::tensorflow::DebugOptions* unsafe_arena_release_debug_options();
  void unsafe_arena_set_allocated_debug_options(
      ::tensorflow::DebugOptions* debug_options);

  // @@protoc_insertion_point(class_scope:tensorflow.RegisterGraphRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  ::tensorflow::GraphDef* graph_def_;
  ::tensorflow::GraphOptions* graph_options_;
  ::tensorflow::DebugOptions* debug_options_;
  bool has_control_flow_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<RegisterGraphRequest> RegisterGraphRequest_default_instance_;

// -------------------------------------------------------------------

class RegisterGraphResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.RegisterGraphResponse) */ {
 public:
  RegisterGraphResponse();
  virtual ~RegisterGraphResponse();

  RegisterGraphResponse(const RegisterGraphResponse& from);

  inline RegisterGraphResponse& operator=(const RegisterGraphResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterGraphResponse& default_instance();

  static const RegisterGraphResponse* internal_default_instance();

  void UnsafeArenaSwap(RegisterGraphResponse* other);
  void Swap(RegisterGraphResponse* other);

  // implements Message ----------------------------------------------

  inline RegisterGraphResponse* New() const { return New(NULL); }

  RegisterGraphResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterGraphResponse& from);
  void MergeFrom(const RegisterGraphResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterGraphResponse* other);
  void UnsafeMergeFrom(const RegisterGraphResponse& from);
  protected:
  explicit RegisterGraphResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string graph_handle = 1;
  void clear_graph_handle();
  static const int kGraphHandleFieldNumber = 1;
  const ::std::string& graph_handle() const;
  void set_graph_handle(const ::std::string& value);
  void set_graph_handle(const char* value);
  void set_graph_handle(const char* value, size_t size);
  ::std::string* mutable_graph_handle();
  ::std::string* release_graph_handle();
  void set_allocated_graph_handle(::std::string* graph_handle);
  ::std::string* unsafe_arena_release_graph_handle();
  void unsafe_arena_set_allocated_graph_handle(
      ::std::string* graph_handle);

  // @@protoc_insertion_point(class_scope:tensorflow.RegisterGraphResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr graph_handle_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<RegisterGraphResponse> RegisterGraphResponse_default_instance_;

// -------------------------------------------------------------------

class DeregisterGraphRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.DeregisterGraphRequest) */ {
 public:
  DeregisterGraphRequest();
  virtual ~DeregisterGraphRequest();

  DeregisterGraphRequest(const DeregisterGraphRequest& from);

  inline DeregisterGraphRequest& operator=(const DeregisterGraphRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeregisterGraphRequest& default_instance();

  static const DeregisterGraphRequest* internal_default_instance();

  void UnsafeArenaSwap(DeregisterGraphRequest* other);
  void Swap(DeregisterGraphRequest* other);

  // implements Message ----------------------------------------------

  inline DeregisterGraphRequest* New() const { return New(NULL); }

  DeregisterGraphRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeregisterGraphRequest& from);
  void MergeFrom(const DeregisterGraphRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeregisterGraphRequest* other);
  void UnsafeMergeFrom(const DeregisterGraphRequest& from);
  protected:
  explicit DeregisterGraphRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_handle = 2;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 2;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);
  ::std::string* unsafe_arena_release_session_handle();
  void unsafe_arena_set_allocated_session_handle(
      ::std::string* session_handle);

  // optional string graph_handle = 1;
  void clear_graph_handle();
  static const int kGraphHandleFieldNumber = 1;
  const ::std::string& graph_handle() const;
  void set_graph_handle(const ::std::string& value);
  void set_graph_handle(const char* value);
  void set_graph_handle(const char* value, size_t size);
  ::std::string* mutable_graph_handle();
  ::std::string* release_graph_handle();
  void set_allocated_graph_handle(::std::string* graph_handle);
  ::std::string* unsafe_arena_release_graph_handle();
  void unsafe_arena_set_allocated_graph_handle(
      ::std::string* graph_handle);

  // @@protoc_insertion_point(class_scope:tensorflow.DeregisterGraphRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  ::google::protobuf::internal::ArenaStringPtr graph_handle_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<DeregisterGraphRequest> DeregisterGraphRequest_default_instance_;

// -------------------------------------------------------------------

class DeregisterGraphResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.DeregisterGraphResponse) */ {
 public:
  DeregisterGraphResponse();
  virtual ~DeregisterGraphResponse();

  DeregisterGraphResponse(const DeregisterGraphResponse& from);

  inline DeregisterGraphResponse& operator=(const DeregisterGraphResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeregisterGraphResponse& default_instance();

  static const DeregisterGraphResponse* internal_default_instance();

  void UnsafeArenaSwap(DeregisterGraphResponse* other);
  void Swap(DeregisterGraphResponse* other);

  // implements Message ----------------------------------------------

  inline DeregisterGraphResponse* New() const { return New(NULL); }

  DeregisterGraphResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeregisterGraphResponse& from);
  void MergeFrom(const DeregisterGraphResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeregisterGraphResponse* other);
  void UnsafeMergeFrom(const DeregisterGraphResponse& from);
  protected:
  explicit DeregisterGraphResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.DeregisterGraphResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<DeregisterGraphResponse> DeregisterGraphResponse_default_instance_;

// -------------------------------------------------------------------

class CleanupAllRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CleanupAllRequest) */ {
 public:
  CleanupAllRequest();
  virtual ~CleanupAllRequest();

  CleanupAllRequest(const CleanupAllRequest& from);

  inline CleanupAllRequest& operator=(const CleanupAllRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CleanupAllRequest& default_instance();

  static const CleanupAllRequest* internal_default_instance();

  void UnsafeArenaSwap(CleanupAllRequest* other);
  void Swap(CleanupAllRequest* other);

  // implements Message ----------------------------------------------

  inline CleanupAllRequest* New() const { return New(NULL); }

  CleanupAllRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CleanupAllRequest& from);
  void MergeFrom(const CleanupAllRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CleanupAllRequest* other);
  void UnsafeMergeFrom(const CleanupAllRequest& from);
  protected:
  explicit CleanupAllRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string container = 1;
  int container_size() const;
  void clear_container();
  static const int kContainerFieldNumber = 1;
  const ::std::string& container(int index) const;
  ::std::string* mutable_container(int index);
  void set_container(int index, const ::std::string& value);
  void set_container(int index, const char* value);
  void set_container(int index, const char* value, size_t size);
  ::std::string* add_container();
  void add_container(const ::std::string& value);
  void add_container(const char* value);
  void add_container(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& container() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_container();

  // @@protoc_insertion_point(class_scope:tensorflow.CleanupAllRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::std::string> container_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CleanupAllRequest> CleanupAllRequest_default_instance_;

// -------------------------------------------------------------------

class CleanupAllResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CleanupAllResponse) */ {
 public:
  CleanupAllResponse();
  virtual ~CleanupAllResponse();

  CleanupAllResponse(const CleanupAllResponse& from);

  inline CleanupAllResponse& operator=(const CleanupAllResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CleanupAllResponse& default_instance();

  static const CleanupAllResponse* internal_default_instance();

  void UnsafeArenaSwap(CleanupAllResponse* other);
  void Swap(CleanupAllResponse* other);

  // implements Message ----------------------------------------------

  inline CleanupAllResponse* New() const { return New(NULL); }

  CleanupAllResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CleanupAllResponse& from);
  void MergeFrom(const CleanupAllResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CleanupAllResponse* other);
  void UnsafeMergeFrom(const CleanupAllResponse& from);
  protected:
  explicit CleanupAllResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.CleanupAllResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CleanupAllResponse> CleanupAllResponse_default_instance_;

// -------------------------------------------------------------------

class ExecutorOpts : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ExecutorOpts) */ {
 public:
  ExecutorOpts();
  virtual ~ExecutorOpts();

  ExecutorOpts(const ExecutorOpts& from);

  inline ExecutorOpts& operator=(const ExecutorOpts& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorOpts& default_instance();

  static const ExecutorOpts* internal_default_instance();

  void UnsafeArenaSwap(ExecutorOpts* other);
  void Swap(ExecutorOpts* other);

  // implements Message ----------------------------------------------

  inline ExecutorOpts* New() const { return New(NULL); }

  ExecutorOpts* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorOpts& from);
  void MergeFrom(const ExecutorOpts& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExecutorOpts* other);
  void UnsafeMergeFrom(const ExecutorOpts& from);
  protected:
  explicit ExecutorOpts(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool record_costs = 1;
  void clear_record_costs();
  static const int kRecordCostsFieldNumber = 1;
  bool record_costs() const;
  void set_record_costs(bool value);

  // optional bool record_timeline = 3;
  void clear_record_timeline();
  static const int kRecordTimelineFieldNumber = 3;
  bool record_timeline() const;
  void set_record_timeline(bool value);

  // optional bool record_partition_graphs = 4;
  void clear_record_partition_graphs();
  static const int kRecordPartitionGraphsFieldNumber = 4;
  bool record_partition_graphs() const;
  void set_record_partition_graphs(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.ExecutorOpts)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool record_costs_;
  bool record_timeline_;
  bool record_partition_graphs_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ExecutorOpts> ExecutorOpts_default_instance_;

// -------------------------------------------------------------------

class RunGraphRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.RunGraphRequest) */ {
 public:
  RunGraphRequest();
  virtual ~RunGraphRequest();

  RunGraphRequest(const RunGraphRequest& from);

  inline RunGraphRequest& operator=(const RunGraphRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunGraphRequest& default_instance();

  static const RunGraphRequest* internal_default_instance();

  void UnsafeArenaSwap(RunGraphRequest* other);
  void Swap(RunGraphRequest* other);

  // implements Message ----------------------------------------------

  inline RunGraphRequest* New() const { return New(NULL); }

  RunGraphRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunGraphRequest& from);
  void MergeFrom(const RunGraphRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RunGraphRequest* other);
  void UnsafeMergeFrom(const RunGraphRequest& from);
  protected:
  explicit RunGraphRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_handle = 8;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 8;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);
  ::std::string* unsafe_arena_release_session_handle();
  void unsafe_arena_set_allocated_session_handle(
      ::std::string* session_handle);

  // optional string graph_handle = 1;
  void clear_graph_handle();
  static const int kGraphHandleFieldNumber = 1;
  const ::std::string& graph_handle() const;
  void set_graph_handle(const ::std::string& value);
  void set_graph_handle(const char* value);
  void set_graph_handle(const char* value, size_t size);
  ::std::string* mutable_graph_handle();
  ::std::string* release_graph_handle();
  void set_allocated_graph_handle(::std::string* graph_handle);
  ::std::string* unsafe_arena_release_graph_handle();
  void unsafe_arena_set_allocated_graph_handle(
      ::std::string* graph_handle);

  // optional int64 step_id = 2;
  void clear_step_id();
  static const int kStepIdFieldNumber = 2;
  ::google::protobuf::int64 step_id() const;
  void set_step_id(::google::protobuf::int64 value);

  // optional .tensorflow.ExecutorOpts exec_opts = 5;
  bool has_exec_opts() const;
  void clear_exec_opts();
  static const int kExecOptsFieldNumber = 5;
  private:
  void _slow_mutable_exec_opts();
  void _slow_set_allocated_exec_opts(
      ::google::protobuf::Arena* message_arena, ::tensorflow::ExecutorOpts** exec_opts);
  ::tensorflow::ExecutorOpts* _slow_release_exec_opts();
  public:
  const ::tensorflow::ExecutorOpts& exec_opts() const;
  ::tensorflow::ExecutorOpts* mutable_exec_opts();
  ::tensorflow::ExecutorOpts* release_exec_opts();
  void set_allocated_exec_opts(::tensorflow::ExecutorOpts* exec_opts);
  ::tensorflow::ExecutorOpts* unsafe_arena_release_exec_opts();
  void unsafe_arena_set_allocated_exec_opts(
      ::tensorflow::ExecutorOpts* exec_opts);

  // repeated .tensorflow.NamedTensorProto send = 3;
  int send_size() const;
  void clear_send();
  static const int kSendFieldNumber = 3;
  const ::tensorflow::NamedTensorProto& send(int index) const;
  ::tensorflow::NamedTensorProto* mutable_send(int index);
  ::tensorflow::NamedTensorProto* add_send();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >*
      mutable_send();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >&
      send() const;

  // repeated string recv_key = 4;
  int recv_key_size() const;
  void clear_recv_key();
  static const int kRecvKeyFieldNumber = 4;
  const ::std::string& recv_key(int index) const;
  ::std::string* mutable_recv_key(int index);
  void set_recv_key(int index, const ::std::string& value);
  void set_recv_key(int index, const char* value);
  void set_recv_key(int index, const char* value, size_t size);
  ::std::string* add_recv_key();
  void add_recv_key(const ::std::string& value);
  void add_recv_key(const char* value);
  void add_recv_key(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& recv_key() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_recv_key();

  // optional bool is_partial = 6;
  void clear_is_partial();
  static const int kIsPartialFieldNumber = 6;
  bool is_partial() const;
  void set_is_partial(bool value);

  // optional bool is_last_partial_run = 7;
  void clear_is_last_partial_run();
  static const int kIsLastPartialRunFieldNumber = 7;
  bool is_last_partial_run() const;
  void set_is_last_partial_run(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.RunGraphRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto > send_;
  ::google::protobuf::RepeatedPtrField< ::std::string> recv_key_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  ::google::protobuf::internal::ArenaStringPtr graph_handle_;
  ::tensorflow::ExecutorOpts* exec_opts_;
  ::google::protobuf::int64 step_id_;
  bool is_partial_;
  bool is_last_partial_run_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<RunGraphRequest> RunGraphRequest_default_instance_;

// -------------------------------------------------------------------

class RunGraphResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.RunGraphResponse) */ {
 public:
  RunGraphResponse();
  virtual ~RunGraphResponse();

  RunGraphResponse(const RunGraphResponse& from);

  inline RunGraphResponse& operator=(const RunGraphResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunGraphResponse& default_instance();

  static const RunGraphResponse* internal_default_instance();

  void UnsafeArenaSwap(RunGraphResponse* other);
  void Swap(RunGraphResponse* other);

  // implements Message ----------------------------------------------

  inline RunGraphResponse* New() const { return New(NULL); }

  RunGraphResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunGraphResponse& from);
  void MergeFrom(const RunGraphResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RunGraphResponse* other);
  void UnsafeMergeFrom(const RunGraphResponse& from);
  protected:
  explicit RunGraphResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.NamedTensorProto recv = 1;
  int recv_size() const;
  void clear_recv();
  static const int kRecvFieldNumber = 1;
  const ::tensorflow::NamedTensorProto& recv(int index) const;
  ::tensorflow::NamedTensorProto* mutable_recv(int index);
  ::tensorflow::NamedTensorProto* add_recv();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >*
      mutable_recv();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >&
      recv() const;

  // optional .tensorflow.StepStats step_stats = 2;
  bool has_step_stats() const;
  void clear_step_stats();
  static const int kStepStatsFieldNumber = 2;
  private:
  void _slow_mutable_step_stats();
  void _slow_set_allocated_step_stats(
      ::google::protobuf::Arena* message_arena, ::tensorflow::StepStats** step_stats);
  ::tensorflow::StepStats* _slow_release_step_stats();
  public:
  const ::tensorflow::StepStats& step_stats() const;
  ::tensorflow::StepStats* mutable_step_stats();
  ::tensorflow::StepStats* release_step_stats();
  void set_allocated_step_stats(::tensorflow::StepStats* step_stats);
  ::tensorflow::StepStats* unsafe_arena_release_step_stats();
  void unsafe_arena_set_allocated_step_stats(
      ::tensorflow::StepStats* step_stats);

  // optional .tensorflow.CostGraphDef cost_graph = 3;
  bool has_cost_graph() const;
  void clear_cost_graph();
  static const int kCostGraphFieldNumber = 3;
  private:
  void _slow_mutable_cost_graph();
  void _slow_set_allocated_cost_graph(
      ::google::protobuf::Arena* message_arena, ::tensorflow::CostGraphDef** cost_graph);
  ::tensorflow::CostGraphDef* _slow_release_cost_graph();
  public:
  const ::tensorflow::CostGraphDef& cost_graph() const;
  ::tensorflow::CostGraphDef* mutable_cost_graph();
  ::tensorflow::CostGraphDef* release_cost_graph();
  void set_allocated_cost_graph(::tensorflow::CostGraphDef* cost_graph);
  ::tensorflow::CostGraphDef* unsafe_arena_release_cost_graph();
  void unsafe_arena_set_allocated_cost_graph(
      ::tensorflow::CostGraphDef* cost_graph);

  // repeated .tensorflow.GraphDef partition_graph = 4;
  int partition_graph_size() const;
  void clear_partition_graph();
  static const int kPartitionGraphFieldNumber = 4;
  const ::tensorflow::GraphDef& partition_graph(int index) const;
  ::tensorflow::GraphDef* mutable_partition_graph(int index);
  ::tensorflow::GraphDef* add_partition_graph();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::GraphDef >*
      mutable_partition_graph();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::GraphDef >&
      partition_graph() const;

  // @@protoc_insertion_point(class_scope:tensorflow.RunGraphResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto > recv_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::GraphDef > partition_graph_;
  ::tensorflow::StepStats* step_stats_;
  ::tensorflow::CostGraphDef* cost_graph_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<RunGraphResponse> RunGraphResponse_default_instance_;

// -------------------------------------------------------------------

class CleanupGraphRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CleanupGraphRequest) */ {
 public:
  CleanupGraphRequest();
  virtual ~CleanupGraphRequest();

  CleanupGraphRequest(const CleanupGraphRequest& from);

  inline CleanupGraphRequest& operator=(const CleanupGraphRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CleanupGraphRequest& default_instance();

  static const CleanupGraphRequest* internal_default_instance();

  void UnsafeArenaSwap(CleanupGraphRequest* other);
  void Swap(CleanupGraphRequest* other);

  // implements Message ----------------------------------------------

  inline CleanupGraphRequest* New() const { return New(NULL); }

  CleanupGraphRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CleanupGraphRequest& from);
  void MergeFrom(const CleanupGraphRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CleanupGraphRequest* other);
  void UnsafeMergeFrom(const CleanupGraphRequest& from);
  protected:
  explicit CleanupGraphRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 step_id = 1;
  void clear_step_id();
  static const int kStepIdFieldNumber = 1;
  ::google::protobuf::int64 step_id() const;
  void set_step_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.CleanupGraphRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::int64 step_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CleanupGraphRequest> CleanupGraphRequest_default_instance_;

// -------------------------------------------------------------------

class CleanupGraphResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CleanupGraphResponse) */ {
 public:
  CleanupGraphResponse();
  virtual ~CleanupGraphResponse();

  CleanupGraphResponse(const CleanupGraphResponse& from);

  inline CleanupGraphResponse& operator=(const CleanupGraphResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CleanupGraphResponse& default_instance();

  static const CleanupGraphResponse* internal_default_instance();

  void UnsafeArenaSwap(CleanupGraphResponse* other);
  void Swap(CleanupGraphResponse* other);

  // implements Message ----------------------------------------------

  inline CleanupGraphResponse* New() const { return New(NULL); }

  CleanupGraphResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CleanupGraphResponse& from);
  void MergeFrom(const CleanupGraphResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CleanupGraphResponse* other);
  void UnsafeMergeFrom(const CleanupGraphResponse& from);
  protected:
  explicit CleanupGraphResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.CleanupGraphResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CleanupGraphResponse> CleanupGraphResponse_default_instance_;

// -------------------------------------------------------------------

class RecvTensorRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.RecvTensorRequest) */ {
 public:
  RecvTensorRequest();
  virtual ~RecvTensorRequest();

  RecvTensorRequest(const RecvTensorRequest& from);

  inline RecvTensorRequest& operator=(const RecvTensorRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RecvTensorRequest& default_instance();

  static const RecvTensorRequest* internal_default_instance();

  void UnsafeArenaSwap(RecvTensorRequest* other);
  void Swap(RecvTensorRequest* other);

  // implements Message ----------------------------------------------

  inline RecvTensorRequest* New() const { return New(NULL); }

  RecvTensorRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecvTensorRequest& from);
  void MergeFrom(const RecvTensorRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecvTensorRequest* other);
  void UnsafeMergeFrom(const RecvTensorRequest& from);
  protected:
  explicit RecvTensorRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 step_id = 1;
  void clear_step_id();
  static const int kStepIdFieldNumber = 1;
  ::google::protobuf::int64 step_id() const;
  void set_step_id(::google::protobuf::int64 value);

  // optional string rendezvous_key = 2;
  void clear_rendezvous_key();
  static const int kRendezvousKeyFieldNumber = 2;
  const ::std::string& rendezvous_key() const;
  void set_rendezvous_key(const ::std::string& value);
  void set_rendezvous_key(const char* value);
  void set_rendezvous_key(const char* value, size_t size);
  ::std::string* mutable_rendezvous_key();
  ::std::string* release_rendezvous_key();
  void set_allocated_rendezvous_key(::std::string* rendezvous_key);
  ::std::string* unsafe_arena_release_rendezvous_key();
  void unsafe_arena_set_allocated_rendezvous_key(
      ::std::string* rendezvous_key);

  // optional bool dma_ok = 3;
  void clear_dma_ok();
  static const int kDmaOkFieldNumber = 3;
  bool dma_ok() const;
  void set_dma_ok(bool value);

  // optional .tensorflow.DeviceLocality client_locality = 4;
  bool has_client_locality() const;
  void clear_client_locality();
  static const int kClientLocalityFieldNumber = 4;
  private:
  void _slow_mutable_client_locality();
  void _slow_set_allocated_client_locality(
      ::google::protobuf::Arena* message_arena, ::tensorflow::DeviceLocality** client_locality);
  ::tensorflow::DeviceLocality* _slow_release_client_locality();
  public:
  const ::tensorflow::DeviceLocality& client_locality() const;
  ::tensorflow::DeviceLocality* mutable_client_locality();
  ::tensorflow::DeviceLocality* release_client_locality();
  void set_allocated_client_locality(::tensorflow::DeviceLocality* client_locality);
  ::tensorflow::DeviceLocality* unsafe_arena_release_client_locality();
  void unsafe_arena_set_allocated_client_locality(
      ::tensorflow::DeviceLocality* client_locality);

  // optional .tensorflow.DeviceLocality server_locality = 5;
  bool has_server_locality() const;
  void clear_server_locality();
  static const int kServerLocalityFieldNumber = 5;
  private:
  void _slow_mutable_server_locality();
  void _slow_set_allocated_server_locality(
      ::google::protobuf::Arena* message_arena, ::tensorflow::DeviceLocality** server_locality);
  ::tensorflow::DeviceLocality* _slow_release_server_locality();
  public:
  const ::tensorflow::DeviceLocality& server_locality() const;
  ::tensorflow::DeviceLocality* mutable_server_locality();
  ::tensorflow::DeviceLocality* release_server_locality();
  void set_allocated_server_locality(::tensorflow::DeviceLocality* server_locality);
  ::tensorflow::DeviceLocality* unsafe_arena_release_server_locality();
  void unsafe_arena_set_allocated_server_locality(
      ::tensorflow::DeviceLocality* server_locality);

  // optional .google.protobuf.Any transport_options = 6;
  bool has_transport_options() const;
  void clear_transport_options();
  static const int kTransportOptionsFieldNumber = 6;
  private:
  void _slow_mutable_transport_options();
  ::google::protobuf::Any* _slow_release_transport_options();
  public:
  const ::google::protobuf::Any& transport_options() const;
  ::google::protobuf::Any* mutable_transport_options();
  ::google::protobuf::Any* release_transport_options();
  void set_allocated_transport_options(::google::protobuf::Any* transport_options);
  ::google::protobuf::Any* unsafe_arena_release_transport_options();
  void unsafe_arena_set_allocated_transport_options(
      ::google::protobuf::Any* transport_options);

  // @@protoc_insertion_point(class_scope:tensorflow.RecvTensorRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr rendezvous_key_;
  ::tensorflow::DeviceLocality* client_locality_;
  ::tensorflow::DeviceLocality* server_locality_;
  ::google::protobuf::Any* transport_options_;
  ::google::protobuf::int64 step_id_;
  bool dma_ok_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<RecvTensorRequest> RecvTensorRequest_default_instance_;

// -------------------------------------------------------------------

class RecvTensorResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.RecvTensorResponse) */ {
 public:
  RecvTensorResponse();
  virtual ~RecvTensorResponse();

  RecvTensorResponse(const RecvTensorResponse& from);

  inline RecvTensorResponse& operator=(const RecvTensorResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RecvTensorResponse& default_instance();

  static const RecvTensorResponse* internal_default_instance();

  void UnsafeArenaSwap(RecvTensorResponse* other);
  void Swap(RecvTensorResponse* other);

  // implements Message ----------------------------------------------

  inline RecvTensorResponse* New() const { return New(NULL); }

  RecvTensorResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecvTensorResponse& from);
  void MergeFrom(const RecvTensorResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecvTensorResponse* other);
  void UnsafeMergeFrom(const RecvTensorResponse& from);
  protected:
  explicit RecvTensorResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tensorflow.TensorProto tensor = 1;
  bool has_tensor() const;
  void clear_tensor();
  static const int kTensorFieldNumber = 1;
  private:
  void _slow_mutable_tensor();
  void _slow_set_allocated_tensor(
      ::google::protobuf::Arena* message_arena, ::tensorflow::TensorProto** tensor);
  ::tensorflow::TensorProto* _slow_release_tensor();
  public:
  const ::tensorflow::TensorProto& tensor() const;
  ::tensorflow::TensorProto* mutable_tensor();
  ::tensorflow::TensorProto* release_tensor();
  void set_allocated_tensor(::tensorflow::TensorProto* tensor);
  ::tensorflow::TensorProto* unsafe_arena_release_tensor();
  void unsafe_arena_set_allocated_tensor(
      ::tensorflow::TensorProto* tensor);

  // optional bool is_dead = 2;
  void clear_is_dead();
  static const int kIsDeadFieldNumber = 2;
  bool is_dead() const;
  void set_is_dead(bool value);

  // optional int64 send_start_micros = 3;
  void clear_send_start_micros();
  static const int kSendStartMicrosFieldNumber = 3;
  ::google::protobuf::int64 send_start_micros() const;
  void set_send_start_micros(::google::protobuf::int64 value);

  // optional .google.protobuf.Any transport_options = 4;
  bool has_transport_options() const;
  void clear_transport_options();
  static const int kTransportOptionsFieldNumber = 4;
  private:
  void _slow_mutable_transport_options();
  ::google::protobuf::Any* _slow_release_transport_options();
  public:
  const ::google::protobuf::Any& transport_options() const;
  ::google::protobuf::Any* mutable_transport_options();
  ::google::protobuf::Any* release_transport_options();
  void set_allocated_transport_options(::google::protobuf::Any* transport_options);
  ::google::protobuf::Any* unsafe_arena_release_transport_options();
  void unsafe_arena_set_allocated_transport_options(
      ::google::protobuf::Any* transport_options);

  // @@protoc_insertion_point(class_scope:tensorflow.RecvTensorResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::TensorProto* tensor_;
  ::google::protobuf::Any* transport_options_;
  ::google::protobuf::int64 send_start_micros_;
  bool is_dead_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<RecvTensorResponse> RecvTensorResponse_default_instance_;

// -------------------------------------------------------------------

class LoggingRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.LoggingRequest) */ {
 public:
  LoggingRequest();
  virtual ~LoggingRequest();

  LoggingRequest(const LoggingRequest& from);

  inline LoggingRequest& operator=(const LoggingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoggingRequest& default_instance();

  static const LoggingRequest* internal_default_instance();

  void UnsafeArenaSwap(LoggingRequest* other);
  void Swap(LoggingRequest* other);

  // implements Message ----------------------------------------------

  inline LoggingRequest* New() const { return New(NULL); }

  LoggingRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoggingRequest& from);
  void MergeFrom(const LoggingRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoggingRequest* other);
  void UnsafeMergeFrom(const LoggingRequest& from);
  protected:
  explicit LoggingRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool rpc_logging = 1;
  void clear_rpc_logging();
  static const int kRpcLoggingFieldNumber = 1;
  bool rpc_logging() const;
  void set_rpc_logging(bool value);

  // optional bool clear = 2;
  void clear_clear();
  static const int kClearFieldNumber = 2;
  bool clear() const;
  void set_clear(bool value);

  // repeated int64 fetch_step_id = 3;
  int fetch_step_id_size() const;
  void clear_fetch_step_id();
  static const int kFetchStepIdFieldNumber = 3;
  ::google::protobuf::int64 fetch_step_id(int index) const;
  void set_fetch_step_id(int index, ::google::protobuf::int64 value);
  void add_fetch_step_id(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      fetch_step_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_fetch_step_id();

  // @@protoc_insertion_point(class_scope:tensorflow.LoggingRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > fetch_step_id_;
  mutable int _fetch_step_id_cached_byte_size_;
  bool rpc_logging_;
  bool clear_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LoggingRequest> LoggingRequest_default_instance_;

// -------------------------------------------------------------------

class LabeledStepStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.LabeledStepStats) */ {
 public:
  LabeledStepStats();
  virtual ~LabeledStepStats();

  LabeledStepStats(const LabeledStepStats& from);

  inline LabeledStepStats& operator=(const LabeledStepStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LabeledStepStats& default_instance();

  static const LabeledStepStats* internal_default_instance();

  void UnsafeArenaSwap(LabeledStepStats* other);
  void Swap(LabeledStepStats* other);

  // implements Message ----------------------------------------------

  inline LabeledStepStats* New() const { return New(NULL); }

  LabeledStepStats* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LabeledStepStats& from);
  void MergeFrom(const LabeledStepStats& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LabeledStepStats* other);
  void UnsafeMergeFrom(const LabeledStepStats& from);
  protected:
  explicit LabeledStepStats(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 step_id = 1;
  void clear_step_id();
  static const int kStepIdFieldNumber = 1;
  ::google::protobuf::int64 step_id() const;
  void set_step_id(::google::protobuf::int64 value);

  // optional .tensorflow.StepStats step_stats = 2;
  bool has_step_stats() const;
  void clear_step_stats();
  static const int kStepStatsFieldNumber = 2;
  private:
  void _slow_mutable_step_stats();
  void _slow_set_allocated_step_stats(
      ::google::protobuf::Arena* message_arena, ::tensorflow::StepStats** step_stats);
  ::tensorflow::StepStats* _slow_release_step_stats();
  public:
  const ::tensorflow::StepStats& step_stats() const;
  ::tensorflow::StepStats* mutable_step_stats();
  ::tensorflow::StepStats* release_step_stats();
  void set_allocated_step_stats(::tensorflow::StepStats* step_stats);
  ::tensorflow::StepStats* unsafe_arena_release_step_stats();
  void unsafe_arena_set_allocated_step_stats(
      ::tensorflow::StepStats* step_stats);

  // @@protoc_insertion_point(class_scope:tensorflow.LabeledStepStats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::StepStats* step_stats_;
  ::google::protobuf::int64 step_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LabeledStepStats> LabeledStepStats_default_instance_;

// -------------------------------------------------------------------

class LoggingResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.LoggingResponse) */ {
 public:
  LoggingResponse();
  virtual ~LoggingResponse();

  LoggingResponse(const LoggingResponse& from);

  inline LoggingResponse& operator=(const LoggingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoggingResponse& default_instance();

  static const LoggingResponse* internal_default_instance();

  void UnsafeArenaSwap(LoggingResponse* other);
  void Swap(LoggingResponse* other);

  // implements Message ----------------------------------------------

  inline LoggingResponse* New() const { return New(NULL); }

  LoggingResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoggingResponse& from);
  void MergeFrom(const LoggingResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoggingResponse* other);
  void UnsafeMergeFrom(const LoggingResponse& from);
  protected:
  explicit LoggingResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.LabeledStepStats step = 1;
  int step_size() const;
  void clear_step();
  static const int kStepFieldNumber = 1;
  const ::tensorflow::LabeledStepStats& step(int index) const;
  ::tensorflow::LabeledStepStats* mutable_step(int index);
  ::tensorflow::LabeledStepStats* add_step();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::LabeledStepStats >*
      mutable_step();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::LabeledStepStats >&
      step() const;

  // @@protoc_insertion_point(class_scope:tensorflow.LoggingResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::LabeledStepStats > step_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LoggingResponse> LoggingResponse_default_instance_;

// -------------------------------------------------------------------

class TraceOpts : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.TraceOpts) */ {
 public:
  TraceOpts();
  virtual ~TraceOpts();

  TraceOpts(const TraceOpts& from);

  inline TraceOpts& operator=(const TraceOpts& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TraceOpts& default_instance();

  static const TraceOpts* internal_default_instance();

  void UnsafeArenaSwap(TraceOpts* other);
  void Swap(TraceOpts* other);

  // implements Message ----------------------------------------------

  inline TraceOpts* New() const { return New(NULL); }

  TraceOpts* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TraceOpts& from);
  void MergeFrom(const TraceOpts& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceOpts* other);
  void UnsafeMergeFrom(const TraceOpts& from);
  protected:
  explicit TraceOpts(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double duration = 1;
  void clear_duration();
  static const int kDurationFieldNumber = 1;
  double duration() const;
  void set_duration(double value);

  // optional bool use_step_profiler = 2;
  void clear_use_step_profiler();
  static const int kUseStepProfilerFieldNumber = 2;
  bool use_step_profiler() const;
  void set_use_step_profiler(bool value);

  // optional bool use_kernel_profiler = 3;
  void clear_use_kernel_profiler();
  static const int kUseKernelProfilerFieldNumber = 3;
  bool use_kernel_profiler() const;
  void set_use_kernel_profiler(bool value);

  // optional bool use_extended_profiler = 4;
  void clear_use_extended_profiler();
  static const int kUseExtendedProfilerFieldNumber = 4;
  bool use_extended_profiler() const;
  void set_use_extended_profiler(bool value);

  // optional bool use_gpu_profiler = 5;
  void clear_use_gpu_profiler();
  static const int kUseGpuProfilerFieldNumber = 5;
  bool use_gpu_profiler() const;
  void set_use_gpu_profiler(bool value);

  // optional bool use_sample_profiler = 6;
  void clear_use_sample_profiler();
  static const int kUseSampleProfilerFieldNumber = 6;
  bool use_sample_profiler() const;
  void set_use_sample_profiler(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.TraceOpts)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double duration_;
  bool use_step_profiler_;
  bool use_kernel_profiler_;
  bool use_extended_profiler_;
  bool use_gpu_profiler_;
  bool use_sample_profiler_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TraceOpts> TraceOpts_default_instance_;

// -------------------------------------------------------------------

class TracingRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.TracingRequest) */ {
 public:
  TracingRequest();
  virtual ~TracingRequest();

  TracingRequest(const TracingRequest& from);

  inline TracingRequest& operator=(const TracingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TracingRequest& default_instance();

  static const TracingRequest* internal_default_instance();

  void UnsafeArenaSwap(TracingRequest* other);
  void Swap(TracingRequest* other);

  // implements Message ----------------------------------------------

  inline TracingRequest* New() const { return New(NULL); }

  TracingRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TracingRequest& from);
  void MergeFrom(const TracingRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TracingRequest* other);
  void UnsafeMergeFrom(const TracingRequest& from);
  protected:
  explicit TracingRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tensorflow.TraceOpts options = 1;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 1;
  private:
  void _slow_mutable_options();
  void _slow_set_allocated_options(
      ::google::protobuf::Arena* message_arena, ::tensorflow::TraceOpts** options);
  ::tensorflow::TraceOpts* _slow_release_options();
  public:
  const ::tensorflow::TraceOpts& options() const;
  ::tensorflow::TraceOpts* mutable_options();
  ::tensorflow::TraceOpts* release_options();
  void set_allocated_options(::tensorflow::TraceOpts* options);
  ::tensorflow::TraceOpts* unsafe_arena_release_options();
  void unsafe_arena_set_allocated_options(
      ::tensorflow::TraceOpts* options);

  // @@protoc_insertion_point(class_scope:tensorflow.TracingRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::TraceOpts* options_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TracingRequest> TracingRequest_default_instance_;

// -------------------------------------------------------------------

class TracingResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.TracingResponse) */ {
 public:
  TracingResponse();
  virtual ~TracingResponse();

  TracingResponse(const TracingResponse& from);

  inline TracingResponse& operator=(const TracingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TracingResponse& default_instance();

  static const TracingResponse* internal_default_instance();

  void UnsafeArenaSwap(TracingResponse* other);
  void Swap(TracingResponse* other);

  // implements Message ----------------------------------------------

  inline TracingResponse* New() const { return New(NULL); }

  TracingResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TracingResponse& from);
  void MergeFrom(const TracingResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TracingResponse* other);
  void UnsafeMergeFrom(const TracingResponse& from);
  protected:
  explicit TracingResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.TracingResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto_impl();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fworker_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TracingResponse> TracingResponse_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// GetStatusRequest

inline const GetStatusRequest* GetStatusRequest::internal_default_instance() {
  return &GetStatusRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// GetStatusResponse

// repeated .tensorflow.DeviceAttributes device_attributes = 1;
inline int GetStatusResponse::device_attributes_size() const {
  return device_attributes_.size();
}
inline void GetStatusResponse::clear_device_attributes() {
  device_attributes_.Clear();
}
inline const ::tensorflow::DeviceAttributes& GetStatusResponse::device_attributes(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.GetStatusResponse.device_attributes)
  return device_attributes_.Get(index);
}
inline ::tensorflow::DeviceAttributes* GetStatusResponse::mutable_device_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.GetStatusResponse.device_attributes)
  return device_attributes_.Mutable(index);
}
inline ::tensorflow::DeviceAttributes* GetStatusResponse::add_device_attributes() {
  // @@protoc_insertion_point(field_add:tensorflow.GetStatusResponse.device_attributes)
  return device_attributes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
GetStatusResponse::mutable_device_attributes() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GetStatusResponse.device_attributes)
  return &device_attributes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
GetStatusResponse::device_attributes() const {
  // @@protoc_insertion_point(field_list:tensorflow.GetStatusResponse.device_attributes)
  return device_attributes_;
}

inline const GetStatusResponse* GetStatusResponse::internal_default_instance() {
  return &GetStatusResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// CreateWorkerSessionRequest

// optional string session_handle = 1;
inline void CreateWorkerSessionRequest::clear_session_handle() {
  session_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& CreateWorkerSessionRequest::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.CreateWorkerSessionRequest.session_handle)
  return session_handle_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateWorkerSessionRequest::set_session_handle(const ::std::string& value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.CreateWorkerSessionRequest.session_handle)
}
inline void CreateWorkerSessionRequest::set_session_handle(const char* value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.CreateWorkerSessionRequest.session_handle)
}
inline void CreateWorkerSessionRequest::set_session_handle(const char* value,
    size_t size) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CreateWorkerSessionRequest.session_handle)
}
inline ::std::string* CreateWorkerSessionRequest::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CreateWorkerSessionRequest.session_handle)
  return session_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CreateWorkerSessionRequest::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.CreateWorkerSessionRequest.session_handle)
  
  return session_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CreateWorkerSessionRequest::unsafe_arena_release_session_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CreateWorkerSessionRequest.session_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return session_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CreateWorkerSessionRequest::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CreateWorkerSessionRequest.session_handle)
}
inline void CreateWorkerSessionRequest::unsafe_arena_set_allocated_session_handle(
    ::std::string* session_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      session_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CreateWorkerSessionRequest.session_handle)
}

// optional .tensorflow.ServerDef server_def = 2;
inline bool CreateWorkerSessionRequest::has_server_def() const {
  return this != internal_default_instance() && server_def_ != NULL;
}
inline void CreateWorkerSessionRequest::clear_server_def() {
  if (GetArenaNoVirtual() == NULL && server_def_ != NULL) delete server_def_;
  server_def_ = NULL;
}
inline const ::tensorflow::ServerDef& CreateWorkerSessionRequest::server_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.CreateWorkerSessionRequest.server_def)
  return server_def_ != NULL ? *server_def_
                         : *::tensorflow::ServerDef::internal_default_instance();
}
inline ::tensorflow::ServerDef* CreateWorkerSessionRequest::mutable_server_def() {
  
  if (server_def_ == NULL) {
    _slow_mutable_server_def();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CreateWorkerSessionRequest.server_def)
  return server_def_;
}
inline ::tensorflow::ServerDef* CreateWorkerSessionRequest::release_server_def() {
  // @@protoc_insertion_point(field_release:tensorflow.CreateWorkerSessionRequest.server_def)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_server_def();
  } else {
    ::tensorflow::ServerDef* temp = server_def_;
    server_def_ = NULL;
    return temp;
  }
}
inline  void CreateWorkerSessionRequest::set_allocated_server_def(::tensorflow::ServerDef* server_def) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_def_;
  }
  if (server_def != NULL) {
    _slow_set_allocated_server_def(message_arena, &server_def);
  }
  server_def_ = server_def;
  if (server_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CreateWorkerSessionRequest.server_def)
}

inline const CreateWorkerSessionRequest* CreateWorkerSessionRequest::internal_default_instance() {
  return &CreateWorkerSessionRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// CreateWorkerSessionResponse

inline const CreateWorkerSessionResponse* CreateWorkerSessionResponse::internal_default_instance() {
  return &CreateWorkerSessionResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// RegisterGraphRequest

// optional string session_handle = 1;
inline void RegisterGraphRequest::clear_session_handle() {
  session_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& RegisterGraphRequest::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.RegisterGraphRequest.session_handle)
  return session_handle_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterGraphRequest::set_session_handle(const ::std::string& value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.RegisterGraphRequest.session_handle)
}
inline void RegisterGraphRequest::set_session_handle(const char* value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.RegisterGraphRequest.session_handle)
}
inline void RegisterGraphRequest::set_session_handle(const char* value,
    size_t size) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RegisterGraphRequest.session_handle)
}
inline ::std::string* RegisterGraphRequest::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.RegisterGraphRequest.session_handle)
  return session_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RegisterGraphRequest::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.RegisterGraphRequest.session_handle)
  
  return session_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RegisterGraphRequest::unsafe_arena_release_session_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.RegisterGraphRequest.session_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return session_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RegisterGraphRequest::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RegisterGraphRequest.session_handle)
}
inline void RegisterGraphRequest::unsafe_arena_set_allocated_session_handle(
    ::std::string* session_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      session_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.RegisterGraphRequest.session_handle)
}

// optional .tensorflow.GraphDef graph_def = 2;
inline bool RegisterGraphRequest::has_graph_def() const {
  return this != internal_default_instance() && graph_def_ != NULL;
}
inline void RegisterGraphRequest::clear_graph_def() {
  if (GetArenaNoVirtual() == NULL && graph_def_ != NULL) delete graph_def_;
  graph_def_ = NULL;
}
inline const ::tensorflow::GraphDef& RegisterGraphRequest::graph_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.RegisterGraphRequest.graph_def)
  return graph_def_ != NULL ? *graph_def_
                         : *::tensorflow::GraphDef::internal_default_instance();
}
inline ::tensorflow::GraphDef* RegisterGraphRequest::mutable_graph_def() {
  
  if (graph_def_ == NULL) {
    _slow_mutable_graph_def();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RegisterGraphRequest.graph_def)
  return graph_def_;
}
inline ::tensorflow::GraphDef* RegisterGraphRequest::release_graph_def() {
  // @@protoc_insertion_point(field_release:tensorflow.RegisterGraphRequest.graph_def)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_graph_def();
  } else {
    ::tensorflow::GraphDef* temp = graph_def_;
    graph_def_ = NULL;
    return temp;
  }
}
inline  void RegisterGraphRequest::set_allocated_graph_def(::tensorflow::GraphDef* graph_def) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete graph_def_;
  }
  if (graph_def != NULL) {
    _slow_set_allocated_graph_def(message_arena, &graph_def);
  }
  graph_def_ = graph_def;
  if (graph_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RegisterGraphRequest.graph_def)
}

// optional bool has_control_flow = 3 [deprecated = true];
inline void RegisterGraphRequest::clear_has_control_flow() {
  has_control_flow_ = false;
}
inline bool RegisterGraphRequest::has_control_flow() const {
  // @@protoc_insertion_point(field_get:tensorflow.RegisterGraphRequest.has_control_flow)
  return has_control_flow_;
}
inline void RegisterGraphRequest::set_has_control_flow(bool value) {
  
  has_control_flow_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RegisterGraphRequest.has_control_flow)
}

// optional .tensorflow.GraphOptions graph_options = 4;
inline bool RegisterGraphRequest::has_graph_options() const {
  return this != internal_default_instance() && graph_options_ != NULL;
}
inline void RegisterGraphRequest::clear_graph_options() {
  if (GetArenaNoVirtual() == NULL && graph_options_ != NULL) delete graph_options_;
  graph_options_ = NULL;
}
inline const ::tensorflow::GraphOptions& RegisterGraphRequest::graph_options() const {
  // @@protoc_insertion_point(field_get:tensorflow.RegisterGraphRequest.graph_options)
  return graph_options_ != NULL ? *graph_options_
                         : *::tensorflow::GraphOptions::internal_default_instance();
}
inline ::tensorflow::GraphOptions* RegisterGraphRequest::mutable_graph_options() {
  
  if (graph_options_ == NULL) {
    _slow_mutable_graph_options();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RegisterGraphRequest.graph_options)
  return graph_options_;
}
inline ::tensorflow::GraphOptions* RegisterGraphRequest::release_graph_options() {
  // @@protoc_insertion_point(field_release:tensorflow.RegisterGraphRequest.graph_options)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_graph_options();
  } else {
    ::tensorflow::GraphOptions* temp = graph_options_;
    graph_options_ = NULL;
    return temp;
  }
}
inline  void RegisterGraphRequest::set_allocated_graph_options(::tensorflow::GraphOptions* graph_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete graph_options_;
  }
  if (graph_options != NULL) {
    _slow_set_allocated_graph_options(message_arena, &graph_options);
  }
  graph_options_ = graph_options;
  if (graph_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RegisterGraphRequest.graph_options)
}

// optional .tensorflow.DebugOptions debug_options = 5;
inline bool RegisterGraphRequest::has_debug_options() const {
  return this != internal_default_instance() && debug_options_ != NULL;
}
inline void RegisterGraphRequest::clear_debug_options() {
  if (GetArenaNoVirtual() == NULL && debug_options_ != NULL) delete debug_options_;
  debug_options_ = NULL;
}
inline const ::tensorflow::DebugOptions& RegisterGraphRequest::debug_options() const {
  // @@protoc_insertion_point(field_get:tensorflow.RegisterGraphRequest.debug_options)
  return debug_options_ != NULL ? *debug_options_
                         : *::tensorflow::DebugOptions::internal_default_instance();
}
inline ::tensorflow::DebugOptions* RegisterGraphRequest::mutable_debug_options() {
  
  if (debug_options_ == NULL) {
    _slow_mutable_debug_options();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RegisterGraphRequest.debug_options)
  return debug_options_;
}
inline ::tensorflow::DebugOptions* RegisterGraphRequest::release_debug_options() {
  // @@protoc_insertion_point(field_release:tensorflow.RegisterGraphRequest.debug_options)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_debug_options();
  } else {
    ::tensorflow::DebugOptions* temp = debug_options_;
    debug_options_ = NULL;
    return temp;
  }
}
inline  void RegisterGraphRequest::set_allocated_debug_options(::tensorflow::DebugOptions* debug_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete debug_options_;
  }
  if (debug_options != NULL) {
    _slow_set_allocated_debug_options(message_arena, &debug_options);
  }
  debug_options_ = debug_options;
  if (debug_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RegisterGraphRequest.debug_options)
}

inline const RegisterGraphRequest* RegisterGraphRequest::internal_default_instance() {
  return &RegisterGraphRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// RegisterGraphResponse

// optional string graph_handle = 1;
inline void RegisterGraphResponse::clear_graph_handle() {
  graph_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& RegisterGraphResponse::graph_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.RegisterGraphResponse.graph_handle)
  return graph_handle_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterGraphResponse::set_graph_handle(const ::std::string& value) {
  
  graph_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.RegisterGraphResponse.graph_handle)
}
inline void RegisterGraphResponse::set_graph_handle(const char* value) {
  
  graph_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.RegisterGraphResponse.graph_handle)
}
inline void RegisterGraphResponse::set_graph_handle(const char* value,
    size_t size) {
  
  graph_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RegisterGraphResponse.graph_handle)
}
inline ::std::string* RegisterGraphResponse::mutable_graph_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.RegisterGraphResponse.graph_handle)
  return graph_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RegisterGraphResponse::release_graph_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.RegisterGraphResponse.graph_handle)
  
  return graph_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RegisterGraphResponse::unsafe_arena_release_graph_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.RegisterGraphResponse.graph_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return graph_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RegisterGraphResponse::set_allocated_graph_handle(::std::string* graph_handle) {
  if (graph_handle != NULL) {
    
  } else {
    
  }
  graph_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), graph_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RegisterGraphResponse.graph_handle)
}
inline void RegisterGraphResponse::unsafe_arena_set_allocated_graph_handle(
    ::std::string* graph_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (graph_handle != NULL) {
    
  } else {
    
  }
  graph_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      graph_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.RegisterGraphResponse.graph_handle)
}

inline const RegisterGraphResponse* RegisterGraphResponse::internal_default_instance() {
  return &RegisterGraphResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// DeregisterGraphRequest

// optional string session_handle = 2;
inline void DeregisterGraphRequest::clear_session_handle() {
  session_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& DeregisterGraphRequest::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.DeregisterGraphRequest.session_handle)
  return session_handle_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeregisterGraphRequest::set_session_handle(const ::std::string& value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.DeregisterGraphRequest.session_handle)
}
inline void DeregisterGraphRequest::set_session_handle(const char* value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.DeregisterGraphRequest.session_handle)
}
inline void DeregisterGraphRequest::set_session_handle(const char* value,
    size_t size) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.DeregisterGraphRequest.session_handle)
}
inline ::std::string* DeregisterGraphRequest::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.DeregisterGraphRequest.session_handle)
  return session_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* DeregisterGraphRequest::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.DeregisterGraphRequest.session_handle)
  
  return session_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* DeregisterGraphRequest::unsafe_arena_release_session_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.DeregisterGraphRequest.session_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return session_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void DeregisterGraphRequest::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DeregisterGraphRequest.session_handle)
}
inline void DeregisterGraphRequest::unsafe_arena_set_allocated_session_handle(
    ::std::string* session_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      session_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.DeregisterGraphRequest.session_handle)
}

// optional string graph_handle = 1;
inline void DeregisterGraphRequest::clear_graph_handle() {
  graph_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& DeregisterGraphRequest::graph_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.DeregisterGraphRequest.graph_handle)
  return graph_handle_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeregisterGraphRequest::set_graph_handle(const ::std::string& value) {
  
  graph_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.DeregisterGraphRequest.graph_handle)
}
inline void DeregisterGraphRequest::set_graph_handle(const char* value) {
  
  graph_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.DeregisterGraphRequest.graph_handle)
}
inline void DeregisterGraphRequest::set_graph_handle(const char* value,
    size_t size) {
  
  graph_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.DeregisterGraphRequest.graph_handle)
}
inline ::std::string* DeregisterGraphRequest::mutable_graph_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.DeregisterGraphRequest.graph_handle)
  return graph_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* DeregisterGraphRequest::release_graph_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.DeregisterGraphRequest.graph_handle)
  
  return graph_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* DeregisterGraphRequest::unsafe_arena_release_graph_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.DeregisterGraphRequest.graph_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return graph_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void DeregisterGraphRequest::set_allocated_graph_handle(::std::string* graph_handle) {
  if (graph_handle != NULL) {
    
  } else {
    
  }
  graph_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), graph_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DeregisterGraphRequest.graph_handle)
}
inline void DeregisterGraphRequest::unsafe_arena_set_allocated_graph_handle(
    ::std::string* graph_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (graph_handle != NULL) {
    
  } else {
    
  }
  graph_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      graph_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.DeregisterGraphRequest.graph_handle)
}

inline const DeregisterGraphRequest* DeregisterGraphRequest::internal_default_instance() {
  return &DeregisterGraphRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// DeregisterGraphResponse

inline const DeregisterGraphResponse* DeregisterGraphResponse::internal_default_instance() {
  return &DeregisterGraphResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// CleanupAllRequest

// repeated string container = 1;
inline int CleanupAllRequest::container_size() const {
  return container_.size();
}
inline void CleanupAllRequest::clear_container() {
  container_.Clear();
}
inline const ::std::string& CleanupAllRequest::container(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.CleanupAllRequest.container)
  return container_.Get(index);
}
inline ::std::string* CleanupAllRequest::mutable_container(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.CleanupAllRequest.container)
  return container_.Mutable(index);
}
inline void CleanupAllRequest::set_container(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.CleanupAllRequest.container)
  container_.Mutable(index)->assign(value);
}
inline void CleanupAllRequest::set_container(int index, const char* value) {
  container_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.CleanupAllRequest.container)
}
inline void CleanupAllRequest::set_container(int index, const char* value, size_t size) {
  container_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CleanupAllRequest.container)
}
inline ::std::string* CleanupAllRequest::add_container() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.CleanupAllRequest.container)
  return container_.Add();
}
inline void CleanupAllRequest::add_container(const ::std::string& value) {
  container_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.CleanupAllRequest.container)
}
inline void CleanupAllRequest::add_container(const char* value) {
  container_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.CleanupAllRequest.container)
}
inline void CleanupAllRequest::add_container(const char* value, size_t size) {
  container_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.CleanupAllRequest.container)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CleanupAllRequest::container() const {
  // @@protoc_insertion_point(field_list:tensorflow.CleanupAllRequest.container)
  return container_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CleanupAllRequest::mutable_container() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CleanupAllRequest.container)
  return &container_;
}

inline const CleanupAllRequest* CleanupAllRequest::internal_default_instance() {
  return &CleanupAllRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// CleanupAllResponse

inline const CleanupAllResponse* CleanupAllResponse::internal_default_instance() {
  return &CleanupAllResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// ExecutorOpts

// optional bool record_costs = 1;
inline void ExecutorOpts::clear_record_costs() {
  record_costs_ = false;
}
inline bool ExecutorOpts::record_costs() const {
  // @@protoc_insertion_point(field_get:tensorflow.ExecutorOpts.record_costs)
  return record_costs_;
}
inline void ExecutorOpts::set_record_costs(bool value) {
  
  record_costs_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.ExecutorOpts.record_costs)
}

// optional bool record_timeline = 3;
inline void ExecutorOpts::clear_record_timeline() {
  record_timeline_ = false;
}
inline bool ExecutorOpts::record_timeline() const {
  // @@protoc_insertion_point(field_get:tensorflow.ExecutorOpts.record_timeline)
  return record_timeline_;
}
inline void ExecutorOpts::set_record_timeline(bool value) {
  
  record_timeline_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.ExecutorOpts.record_timeline)
}

// optional bool record_partition_graphs = 4;
inline void ExecutorOpts::clear_record_partition_graphs() {
  record_partition_graphs_ = false;
}
inline bool ExecutorOpts::record_partition_graphs() const {
  // @@protoc_insertion_point(field_get:tensorflow.ExecutorOpts.record_partition_graphs)
  return record_partition_graphs_;
}
inline void ExecutorOpts::set_record_partition_graphs(bool value) {
  
  record_partition_graphs_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.ExecutorOpts.record_partition_graphs)
}

inline const ExecutorOpts* ExecutorOpts::internal_default_instance() {
  return &ExecutorOpts_default_instance_.get();
}
// -------------------------------------------------------------------

// RunGraphRequest

// optional string session_handle = 8;
inline void RunGraphRequest::clear_session_handle() {
  session_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& RunGraphRequest::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunGraphRequest.session_handle)
  return session_handle_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunGraphRequest::set_session_handle(const ::std::string& value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.RunGraphRequest.session_handle)
}
inline void RunGraphRequest::set_session_handle(const char* value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.RunGraphRequest.session_handle)
}
inline void RunGraphRequest::set_session_handle(const char* value,
    size_t size) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RunGraphRequest.session_handle)
}
inline ::std::string* RunGraphRequest::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.RunGraphRequest.session_handle)
  return session_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RunGraphRequest::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.RunGraphRequest.session_handle)
  
  return session_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RunGraphRequest::unsafe_arena_release_session_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.RunGraphRequest.session_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return session_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RunGraphRequest::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunGraphRequest.session_handle)
}
inline void RunGraphRequest::unsafe_arena_set_allocated_session_handle(
    ::std::string* session_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      session_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.RunGraphRequest.session_handle)
}

// optional string graph_handle = 1;
inline void RunGraphRequest::clear_graph_handle() {
  graph_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& RunGraphRequest::graph_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunGraphRequest.graph_handle)
  return graph_handle_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunGraphRequest::set_graph_handle(const ::std::string& value) {
  
  graph_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.RunGraphRequest.graph_handle)
}
inline void RunGraphRequest::set_graph_handle(const char* value) {
  
  graph_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.RunGraphRequest.graph_handle)
}
inline void RunGraphRequest::set_graph_handle(const char* value,
    size_t size) {
  
  graph_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RunGraphRequest.graph_handle)
}
inline ::std::string* RunGraphRequest::mutable_graph_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.RunGraphRequest.graph_handle)
  return graph_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RunGraphRequest::release_graph_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.RunGraphRequest.graph_handle)
  
  return graph_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RunGraphRequest::unsafe_arena_release_graph_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.RunGraphRequest.graph_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return graph_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RunGraphRequest::set_allocated_graph_handle(::std::string* graph_handle) {
  if (graph_handle != NULL) {
    
  } else {
    
  }
  graph_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), graph_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunGraphRequest.graph_handle)
}
inline void RunGraphRequest::unsafe_arena_set_allocated_graph_handle(
    ::std::string* graph_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (graph_handle != NULL) {
    
  } else {
    
  }
  graph_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      graph_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.RunGraphRequest.graph_handle)
}

// optional int64 step_id = 2;
inline void RunGraphRequest::clear_step_id() {
  step_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RunGraphRequest::step_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunGraphRequest.step_id)
  return step_id_;
}
inline void RunGraphRequest::set_step_id(::google::protobuf::int64 value) {
  
  step_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RunGraphRequest.step_id)
}

// optional .tensorflow.ExecutorOpts exec_opts = 5;
inline bool RunGraphRequest::has_exec_opts() const {
  return this != internal_default_instance() && exec_opts_ != NULL;
}
inline void RunGraphRequest::clear_exec_opts() {
  if (GetArenaNoVirtual() == NULL && exec_opts_ != NULL) delete exec_opts_;
  exec_opts_ = NULL;
}
inline const ::tensorflow::ExecutorOpts& RunGraphRequest::exec_opts() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunGraphRequest.exec_opts)
  return exec_opts_ != NULL ? *exec_opts_
                         : *::tensorflow::ExecutorOpts::internal_default_instance();
}
inline ::tensorflow::ExecutorOpts* RunGraphRequest::mutable_exec_opts() {
  
  if (exec_opts_ == NULL) {
    _slow_mutable_exec_opts();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RunGraphRequest.exec_opts)
  return exec_opts_;
}
inline ::tensorflow::ExecutorOpts* RunGraphRequest::release_exec_opts() {
  // @@protoc_insertion_point(field_release:tensorflow.RunGraphRequest.exec_opts)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_exec_opts();
  } else {
    ::tensorflow::ExecutorOpts* temp = exec_opts_;
    exec_opts_ = NULL;
    return temp;
  }
}
inline  void RunGraphRequest::set_allocated_exec_opts(::tensorflow::ExecutorOpts* exec_opts) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete exec_opts_;
  }
  if (exec_opts != NULL) {
    _slow_set_allocated_exec_opts(message_arena, &exec_opts);
  }
  exec_opts_ = exec_opts;
  if (exec_opts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunGraphRequest.exec_opts)
}

// repeated .tensorflow.NamedTensorProto send = 3;
inline int RunGraphRequest::send_size() const {
  return send_.size();
}
inline void RunGraphRequest::clear_send() {
  send_.Clear();
}
inline const ::tensorflow::NamedTensorProto& RunGraphRequest::send(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.RunGraphRequest.send)
  return send_.Get(index);
}
inline ::tensorflow::NamedTensorProto* RunGraphRequest::mutable_send(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunGraphRequest.send)
  return send_.Mutable(index);
}
inline ::tensorflow::NamedTensorProto* RunGraphRequest::add_send() {
  // @@protoc_insertion_point(field_add:tensorflow.RunGraphRequest.send)
  return send_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >*
RunGraphRequest::mutable_send() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunGraphRequest.send)
  return &send_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >&
RunGraphRequest::send() const {
  // @@protoc_insertion_point(field_list:tensorflow.RunGraphRequest.send)
  return send_;
}

// repeated string recv_key = 4;
inline int RunGraphRequest::recv_key_size() const {
  return recv_key_.size();
}
inline void RunGraphRequest::clear_recv_key() {
  recv_key_.Clear();
}
inline const ::std::string& RunGraphRequest::recv_key(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.RunGraphRequest.recv_key)
  return recv_key_.Get(index);
}
inline ::std::string* RunGraphRequest::mutable_recv_key(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunGraphRequest.recv_key)
  return recv_key_.Mutable(index);
}
inline void RunGraphRequest::set_recv_key(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.RunGraphRequest.recv_key)
  recv_key_.Mutable(index)->assign(value);
}
inline void RunGraphRequest::set_recv_key(int index, const char* value) {
  recv_key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.RunGraphRequest.recv_key)
}
inline void RunGraphRequest::set_recv_key(int index, const char* value, size_t size) {
  recv_key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RunGraphRequest.recv_key)
}
inline ::std::string* RunGraphRequest::add_recv_key() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.RunGraphRequest.recv_key)
  return recv_key_.Add();
}
inline void RunGraphRequest::add_recv_key(const ::std::string& value) {
  recv_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.RunGraphRequest.recv_key)
}
inline void RunGraphRequest::add_recv_key(const char* value) {
  recv_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.RunGraphRequest.recv_key)
}
inline void RunGraphRequest::add_recv_key(const char* value, size_t size) {
  recv_key_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.RunGraphRequest.recv_key)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RunGraphRequest::recv_key() const {
  // @@protoc_insertion_point(field_list:tensorflow.RunGraphRequest.recv_key)
  return recv_key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RunGraphRequest::mutable_recv_key() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunGraphRequest.recv_key)
  return &recv_key_;
}

// optional bool is_partial = 6;
inline void RunGraphRequest::clear_is_partial() {
  is_partial_ = false;
}
inline bool RunGraphRequest::is_partial() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunGraphRequest.is_partial)
  return is_partial_;
}
inline void RunGraphRequest::set_is_partial(bool value) {
  
  is_partial_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RunGraphRequest.is_partial)
}

// optional bool is_last_partial_run = 7;
inline void RunGraphRequest::clear_is_last_partial_run() {
  is_last_partial_run_ = false;
}
inline bool RunGraphRequest::is_last_partial_run() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunGraphRequest.is_last_partial_run)
  return is_last_partial_run_;
}
inline void RunGraphRequest::set_is_last_partial_run(bool value) {
  
  is_last_partial_run_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RunGraphRequest.is_last_partial_run)
}

inline const RunGraphRequest* RunGraphRequest::internal_default_instance() {
  return &RunGraphRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// RunGraphResponse

// repeated .tensorflow.NamedTensorProto recv = 1;
inline int RunGraphResponse::recv_size() const {
  return recv_.size();
}
inline void RunGraphResponse::clear_recv() {
  recv_.Clear();
}
inline const ::tensorflow::NamedTensorProto& RunGraphResponse::recv(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.RunGraphResponse.recv)
  return recv_.Get(index);
}
inline ::tensorflow::NamedTensorProto* RunGraphResponse::mutable_recv(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunGraphResponse.recv)
  return recv_.Mutable(index);
}
inline ::tensorflow::NamedTensorProto* RunGraphResponse::add_recv() {
  // @@protoc_insertion_point(field_add:tensorflow.RunGraphResponse.recv)
  return recv_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >*
RunGraphResponse::mutable_recv() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunGraphResponse.recv)
  return &recv_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >&
RunGraphResponse::recv() const {
  // @@protoc_insertion_point(field_list:tensorflow.RunGraphResponse.recv)
  return recv_;
}

// optional .tensorflow.StepStats step_stats = 2;
inline bool RunGraphResponse::has_step_stats() const {
  return this != internal_default_instance() && step_stats_ != NULL;
}
inline void RunGraphResponse::clear_step_stats() {
  if (GetArenaNoVirtual() == NULL && step_stats_ != NULL) delete step_stats_;
  step_stats_ = NULL;
}
inline const ::tensorflow::StepStats& RunGraphResponse::step_stats() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunGraphResponse.step_stats)
  return step_stats_ != NULL ? *step_stats_
                         : *::tensorflow::StepStats::internal_default_instance();
}
inline ::tensorflow::StepStats* RunGraphResponse::mutable_step_stats() {
  
  if (step_stats_ == NULL) {
    _slow_mutable_step_stats();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RunGraphResponse.step_stats)
  return step_stats_;
}
inline ::tensorflow::StepStats* RunGraphResponse::release_step_stats() {
  // @@protoc_insertion_point(field_release:tensorflow.RunGraphResponse.step_stats)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_step_stats();
  } else {
    ::tensorflow::StepStats* temp = step_stats_;
    step_stats_ = NULL;
    return temp;
  }
}
inline  void RunGraphResponse::set_allocated_step_stats(::tensorflow::StepStats* step_stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete step_stats_;
  }
  if (step_stats != NULL) {
    _slow_set_allocated_step_stats(message_arena, &step_stats);
  }
  step_stats_ = step_stats;
  if (step_stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunGraphResponse.step_stats)
}

// optional .tensorflow.CostGraphDef cost_graph = 3;
inline bool RunGraphResponse::has_cost_graph() const {
  return this != internal_default_instance() && cost_graph_ != NULL;
}
inline void RunGraphResponse::clear_cost_graph() {
  if (GetArenaNoVirtual() == NULL && cost_graph_ != NULL) delete cost_graph_;
  cost_graph_ = NULL;
}
inline const ::tensorflow::CostGraphDef& RunGraphResponse::cost_graph() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunGraphResponse.cost_graph)
  return cost_graph_ != NULL ? *cost_graph_
                         : *::tensorflow::CostGraphDef::internal_default_instance();
}
inline ::tensorflow::CostGraphDef* RunGraphResponse::mutable_cost_graph() {
  
  if (cost_graph_ == NULL) {
    _slow_mutable_cost_graph();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RunGraphResponse.cost_graph)
  return cost_graph_;
}
inline ::tensorflow::CostGraphDef* RunGraphResponse::release_cost_graph() {
  // @@protoc_insertion_point(field_release:tensorflow.RunGraphResponse.cost_graph)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_cost_graph();
  } else {
    ::tensorflow::CostGraphDef* temp = cost_graph_;
    cost_graph_ = NULL;
    return temp;
  }
}
inline  void RunGraphResponse::set_allocated_cost_graph(::tensorflow::CostGraphDef* cost_graph) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cost_graph_;
  }
  if (cost_graph != NULL) {
    _slow_set_allocated_cost_graph(message_arena, &cost_graph);
  }
  cost_graph_ = cost_graph;
  if (cost_graph) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunGraphResponse.cost_graph)
}

// repeated .tensorflow.GraphDef partition_graph = 4;
inline int RunGraphResponse::partition_graph_size() const {
  return partition_graph_.size();
}
inline void RunGraphResponse::clear_partition_graph() {
  partition_graph_.Clear();
}
inline const ::tensorflow::GraphDef& RunGraphResponse::partition_graph(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.RunGraphResponse.partition_graph)
  return partition_graph_.Get(index);
}
inline ::tensorflow::GraphDef* RunGraphResponse::mutable_partition_graph(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunGraphResponse.partition_graph)
  return partition_graph_.Mutable(index);
}
inline ::tensorflow::GraphDef* RunGraphResponse::add_partition_graph() {
  // @@protoc_insertion_point(field_add:tensorflow.RunGraphResponse.partition_graph)
  return partition_graph_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::GraphDef >*
RunGraphResponse::mutable_partition_graph() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunGraphResponse.partition_graph)
  return &partition_graph_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::GraphDef >&
RunGraphResponse::partition_graph() const {
  // @@protoc_insertion_point(field_list:tensorflow.RunGraphResponse.partition_graph)
  return partition_graph_;
}

inline const RunGraphResponse* RunGraphResponse::internal_default_instance() {
  return &RunGraphResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// CleanupGraphRequest

// optional int64 step_id = 1;
inline void CleanupGraphRequest::clear_step_id() {
  step_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CleanupGraphRequest::step_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.CleanupGraphRequest.step_id)
  return step_id_;
}
inline void CleanupGraphRequest::set_step_id(::google::protobuf::int64 value) {
  
  step_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CleanupGraphRequest.step_id)
}

inline const CleanupGraphRequest* CleanupGraphRequest::internal_default_instance() {
  return &CleanupGraphRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// CleanupGraphResponse

inline const CleanupGraphResponse* CleanupGraphResponse::internal_default_instance() {
  return &CleanupGraphResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// RecvTensorRequest

// optional int64 step_id = 1;
inline void RecvTensorRequest::clear_step_id() {
  step_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RecvTensorRequest::step_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.RecvTensorRequest.step_id)
  return step_id_;
}
inline void RecvTensorRequest::set_step_id(::google::protobuf::int64 value) {
  
  step_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RecvTensorRequest.step_id)
}

// optional string rendezvous_key = 2;
inline void RecvTensorRequest::clear_rendezvous_key() {
  rendezvous_key_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& RecvTensorRequest::rendezvous_key() const {
  // @@protoc_insertion_point(field_get:tensorflow.RecvTensorRequest.rendezvous_key)
  return rendezvous_key_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecvTensorRequest::set_rendezvous_key(const ::std::string& value) {
  
  rendezvous_key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.RecvTensorRequest.rendezvous_key)
}
inline void RecvTensorRequest::set_rendezvous_key(const char* value) {
  
  rendezvous_key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.RecvTensorRequest.rendezvous_key)
}
inline void RecvTensorRequest::set_rendezvous_key(const char* value,
    size_t size) {
  
  rendezvous_key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RecvTensorRequest.rendezvous_key)
}
inline ::std::string* RecvTensorRequest::mutable_rendezvous_key() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.RecvTensorRequest.rendezvous_key)
  return rendezvous_key_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RecvTensorRequest::release_rendezvous_key() {
  // @@protoc_insertion_point(field_release:tensorflow.RecvTensorRequest.rendezvous_key)
  
  return rendezvous_key_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RecvTensorRequest::unsafe_arena_release_rendezvous_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.RecvTensorRequest.rendezvous_key)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return rendezvous_key_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RecvTensorRequest::set_allocated_rendezvous_key(::std::string* rendezvous_key) {
  if (rendezvous_key != NULL) {
    
  } else {
    
  }
  rendezvous_key_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rendezvous_key,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RecvTensorRequest.rendezvous_key)
}
inline void RecvTensorRequest::unsafe_arena_set_allocated_rendezvous_key(
    ::std::string* rendezvous_key) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (rendezvous_key != NULL) {
    
  } else {
    
  }
  rendezvous_key_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      rendezvous_key, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.RecvTensorRequest.rendezvous_key)
}

// optional bool dma_ok = 3;
inline void RecvTensorRequest::clear_dma_ok() {
  dma_ok_ = false;
}
inline bool RecvTensorRequest::dma_ok() const {
  // @@protoc_insertion_point(field_get:tensorflow.RecvTensorRequest.dma_ok)
  return dma_ok_;
}
inline void RecvTensorRequest::set_dma_ok(bool value) {
  
  dma_ok_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RecvTensorRequest.dma_ok)
}

// optional .tensorflow.DeviceLocality client_locality = 4;
inline bool RecvTensorRequest::has_client_locality() const {
  return this != internal_default_instance() && client_locality_ != NULL;
}
inline void RecvTensorRequest::clear_client_locality() {
  if (GetArenaNoVirtual() == NULL && client_locality_ != NULL) delete client_locality_;
  client_locality_ = NULL;
}
inline const ::tensorflow::DeviceLocality& RecvTensorRequest::client_locality() const {
  // @@protoc_insertion_point(field_get:tensorflow.RecvTensorRequest.client_locality)
  return client_locality_ != NULL ? *client_locality_
                         : *::tensorflow::DeviceLocality::internal_default_instance();
}
inline ::tensorflow::DeviceLocality* RecvTensorRequest::mutable_client_locality() {
  
  if (client_locality_ == NULL) {
    _slow_mutable_client_locality();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RecvTensorRequest.client_locality)
  return client_locality_;
}
inline ::tensorflow::DeviceLocality* RecvTensorRequest::release_client_locality() {
  // @@protoc_insertion_point(field_release:tensorflow.RecvTensorRequest.client_locality)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_client_locality();
  } else {
    ::tensorflow::DeviceLocality* temp = client_locality_;
    client_locality_ = NULL;
    return temp;
  }
}
inline  void RecvTensorRequest::set_allocated_client_locality(::tensorflow::DeviceLocality* client_locality) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete client_locality_;
  }
  if (client_locality != NULL) {
    _slow_set_allocated_client_locality(message_arena, &client_locality);
  }
  client_locality_ = client_locality;
  if (client_locality) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RecvTensorRequest.client_locality)
}

// optional .tensorflow.DeviceLocality server_locality = 5;
inline bool RecvTensorRequest::has_server_locality() const {
  return this != internal_default_instance() && server_locality_ != NULL;
}
inline void RecvTensorRequest::clear_server_locality() {
  if (GetArenaNoVirtual() == NULL && server_locality_ != NULL) delete server_locality_;
  server_locality_ = NULL;
}
inline const ::tensorflow::DeviceLocality& RecvTensorRequest::server_locality() const {
  // @@protoc_insertion_point(field_get:tensorflow.RecvTensorRequest.server_locality)
  return server_locality_ != NULL ? *server_locality_
                         : *::tensorflow::DeviceLocality::internal_default_instance();
}
inline ::tensorflow::DeviceLocality* RecvTensorRequest::mutable_server_locality() {
  
  if (server_locality_ == NULL) {
    _slow_mutable_server_locality();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RecvTensorRequest.server_locality)
  return server_locality_;
}
inline ::tensorflow::DeviceLocality* RecvTensorRequest::release_server_locality() {
  // @@protoc_insertion_point(field_release:tensorflow.RecvTensorRequest.server_locality)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_server_locality();
  } else {
    ::tensorflow::DeviceLocality* temp = server_locality_;
    server_locality_ = NULL;
    return temp;
  }
}
inline  void RecvTensorRequest::set_allocated_server_locality(::tensorflow::DeviceLocality* server_locality) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_locality_;
  }
  if (server_locality != NULL) {
    _slow_set_allocated_server_locality(message_arena, &server_locality);
  }
  server_locality_ = server_locality;
  if (server_locality) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RecvTensorRequest.server_locality)
}

// optional .google.protobuf.Any transport_options = 6;
inline bool RecvTensorRequest::has_transport_options() const {
  return this != internal_default_instance() && transport_options_ != NULL;
}
inline void RecvTensorRequest::clear_transport_options() {
  if (GetArenaNoVirtual() == NULL && transport_options_ != NULL) delete transport_options_;
  transport_options_ = NULL;
}
inline const ::google::protobuf::Any& RecvTensorRequest::transport_options() const {
  // @@protoc_insertion_point(field_get:tensorflow.RecvTensorRequest.transport_options)
  return transport_options_ != NULL ? *transport_options_
                         : *::google::protobuf::Any::internal_default_instance();
}
inline ::google::protobuf::Any* RecvTensorRequest::mutable_transport_options() {
  
  if (transport_options_ == NULL) {
    _slow_mutable_transport_options();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RecvTensorRequest.transport_options)
  return transport_options_;
}
inline ::google::protobuf::Any* RecvTensorRequest::release_transport_options() {
  // @@protoc_insertion_point(field_release:tensorflow.RecvTensorRequest.transport_options)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_transport_options();
  } else {
    ::google::protobuf::Any* temp = transport_options_;
    transport_options_ = NULL;
    return temp;
  }
}
inline  void RecvTensorRequest::set_allocated_transport_options(::google::protobuf::Any* transport_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transport_options_;
  }
  if (transport_options != NULL) {
    if (message_arena != NULL) {
      message_arena->Own(transport_options);
    }
  }
  transport_options_ = transport_options;
  if (transport_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RecvTensorRequest.transport_options)
}

inline const RecvTensorRequest* RecvTensorRequest::internal_default_instance() {
  return &RecvTensorRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// RecvTensorResponse

// optional .tensorflow.TensorProto tensor = 1;
inline bool RecvTensorResponse::has_tensor() const {
  return this != internal_default_instance() && tensor_ != NULL;
}
inline void RecvTensorResponse::clear_tensor() {
  if (GetArenaNoVirtual() == NULL && tensor_ != NULL) delete tensor_;
  tensor_ = NULL;
}
inline const ::tensorflow::TensorProto& RecvTensorResponse::tensor() const {
  // @@protoc_insertion_point(field_get:tensorflow.RecvTensorResponse.tensor)
  return tensor_ != NULL ? *tensor_
                         : *::tensorflow::TensorProto::internal_default_instance();
}
inline ::tensorflow::TensorProto* RecvTensorResponse::mutable_tensor() {
  
  if (tensor_ == NULL) {
    _slow_mutable_tensor();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RecvTensorResponse.tensor)
  return tensor_;
}
inline ::tensorflow::TensorProto* RecvTensorResponse::release_tensor() {
  // @@protoc_insertion_point(field_release:tensorflow.RecvTensorResponse.tensor)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_tensor();
  } else {
    ::tensorflow::TensorProto* temp = tensor_;
    tensor_ = NULL;
    return temp;
  }
}
inline  void RecvTensorResponse::set_allocated_tensor(::tensorflow::TensorProto* tensor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tensor_;
  }
  if (tensor != NULL) {
    _slow_set_allocated_tensor(message_arena, &tensor);
  }
  tensor_ = tensor;
  if (tensor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RecvTensorResponse.tensor)
}

// optional bool is_dead = 2;
inline void RecvTensorResponse::clear_is_dead() {
  is_dead_ = false;
}
inline bool RecvTensorResponse::is_dead() const {
  // @@protoc_insertion_point(field_get:tensorflow.RecvTensorResponse.is_dead)
  return is_dead_;
}
inline void RecvTensorResponse::set_is_dead(bool value) {
  
  is_dead_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RecvTensorResponse.is_dead)
}

// optional int64 send_start_micros = 3;
inline void RecvTensorResponse::clear_send_start_micros() {
  send_start_micros_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RecvTensorResponse::send_start_micros() const {
  // @@protoc_insertion_point(field_get:tensorflow.RecvTensorResponse.send_start_micros)
  return send_start_micros_;
}
inline void RecvTensorResponse::set_send_start_micros(::google::protobuf::int64 value) {
  
  send_start_micros_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RecvTensorResponse.send_start_micros)
}

// optional .google.protobuf.Any transport_options = 4;
inline bool RecvTensorResponse::has_transport_options() const {
  return this != internal_default_instance() && transport_options_ != NULL;
}
inline void RecvTensorResponse::clear_transport_options() {
  if (GetArenaNoVirtual() == NULL && transport_options_ != NULL) delete transport_options_;
  transport_options_ = NULL;
}
inline const ::google::protobuf::Any& RecvTensorResponse::transport_options() const {
  // @@protoc_insertion_point(field_get:tensorflow.RecvTensorResponse.transport_options)
  return transport_options_ != NULL ? *transport_options_
                         : *::google::protobuf::Any::internal_default_instance();
}
inline ::google::protobuf::Any* RecvTensorResponse::mutable_transport_options() {
  
  if (transport_options_ == NULL) {
    _slow_mutable_transport_options();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RecvTensorResponse.transport_options)
  return transport_options_;
}
inline ::google::protobuf::Any* RecvTensorResponse::release_transport_options() {
  // @@protoc_insertion_point(field_release:tensorflow.RecvTensorResponse.transport_options)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_transport_options();
  } else {
    ::google::protobuf::Any* temp = transport_options_;
    transport_options_ = NULL;
    return temp;
  }
}
inline  void RecvTensorResponse::set_allocated_transport_options(::google::protobuf::Any* transport_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transport_options_;
  }
  if (transport_options != NULL) {
    if (message_arena != NULL) {
      message_arena->Own(transport_options);
    }
  }
  transport_options_ = transport_options;
  if (transport_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RecvTensorResponse.transport_options)
}

inline const RecvTensorResponse* RecvTensorResponse::internal_default_instance() {
  return &RecvTensorResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// LoggingRequest

// optional bool rpc_logging = 1;
inline void LoggingRequest::clear_rpc_logging() {
  rpc_logging_ = false;
}
inline bool LoggingRequest::rpc_logging() const {
  // @@protoc_insertion_point(field_get:tensorflow.LoggingRequest.rpc_logging)
  return rpc_logging_;
}
inline void LoggingRequest::set_rpc_logging(bool value) {
  
  rpc_logging_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.LoggingRequest.rpc_logging)
}

// optional bool clear = 2;
inline void LoggingRequest::clear_clear() {
  clear_ = false;
}
inline bool LoggingRequest::clear() const {
  // @@protoc_insertion_point(field_get:tensorflow.LoggingRequest.clear)
  return clear_;
}
inline void LoggingRequest::set_clear(bool value) {
  
  clear_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.LoggingRequest.clear)
}

// repeated int64 fetch_step_id = 3;
inline int LoggingRequest::fetch_step_id_size() const {
  return fetch_step_id_.size();
}
inline void LoggingRequest::clear_fetch_step_id() {
  fetch_step_id_.Clear();
}
inline ::google::protobuf::int64 LoggingRequest::fetch_step_id(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.LoggingRequest.fetch_step_id)
  return fetch_step_id_.Get(index);
}
inline void LoggingRequest::set_fetch_step_id(int index, ::google::protobuf::int64 value) {
  fetch_step_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.LoggingRequest.fetch_step_id)
}
inline void LoggingRequest::add_fetch_step_id(::google::protobuf::int64 value) {
  fetch_step_id_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.LoggingRequest.fetch_step_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
LoggingRequest::fetch_step_id() const {
  // @@protoc_insertion_point(field_list:tensorflow.LoggingRequest.fetch_step_id)
  return fetch_step_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
LoggingRequest::mutable_fetch_step_id() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.LoggingRequest.fetch_step_id)
  return &fetch_step_id_;
}

inline const LoggingRequest* LoggingRequest::internal_default_instance() {
  return &LoggingRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// LabeledStepStats

// optional int64 step_id = 1;
inline void LabeledStepStats::clear_step_id() {
  step_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LabeledStepStats::step_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.LabeledStepStats.step_id)
  return step_id_;
}
inline void LabeledStepStats::set_step_id(::google::protobuf::int64 value) {
  
  step_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.LabeledStepStats.step_id)
}

// optional .tensorflow.StepStats step_stats = 2;
inline bool LabeledStepStats::has_step_stats() const {
  return this != internal_default_instance() && step_stats_ != NULL;
}
inline void LabeledStepStats::clear_step_stats() {
  if (GetArenaNoVirtual() == NULL && step_stats_ != NULL) delete step_stats_;
  step_stats_ = NULL;
}
inline const ::tensorflow::StepStats& LabeledStepStats::step_stats() const {
  // @@protoc_insertion_point(field_get:tensorflow.LabeledStepStats.step_stats)
  return step_stats_ != NULL ? *step_stats_
                         : *::tensorflow::StepStats::internal_default_instance();
}
inline ::tensorflow::StepStats* LabeledStepStats::mutable_step_stats() {
  
  if (step_stats_ == NULL) {
    _slow_mutable_step_stats();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.LabeledStepStats.step_stats)
  return step_stats_;
}
inline ::tensorflow::StepStats* LabeledStepStats::release_step_stats() {
  // @@protoc_insertion_point(field_release:tensorflow.LabeledStepStats.step_stats)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_step_stats();
  } else {
    ::tensorflow::StepStats* temp = step_stats_;
    step_stats_ = NULL;
    return temp;
  }
}
inline  void LabeledStepStats::set_allocated_step_stats(::tensorflow::StepStats* step_stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete step_stats_;
  }
  if (step_stats != NULL) {
    _slow_set_allocated_step_stats(message_arena, &step_stats);
  }
  step_stats_ = step_stats;
  if (step_stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.LabeledStepStats.step_stats)
}

inline const LabeledStepStats* LabeledStepStats::internal_default_instance() {
  return &LabeledStepStats_default_instance_.get();
}
// -------------------------------------------------------------------

// LoggingResponse

// repeated .tensorflow.LabeledStepStats step = 1;
inline int LoggingResponse::step_size() const {
  return step_.size();
}
inline void LoggingResponse::clear_step() {
  step_.Clear();
}
inline const ::tensorflow::LabeledStepStats& LoggingResponse::step(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.LoggingResponse.step)
  return step_.Get(index);
}
inline ::tensorflow::LabeledStepStats* LoggingResponse::mutable_step(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.LoggingResponse.step)
  return step_.Mutable(index);
}
inline ::tensorflow::LabeledStepStats* LoggingResponse::add_step() {
  // @@protoc_insertion_point(field_add:tensorflow.LoggingResponse.step)
  return step_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::LabeledStepStats >*
LoggingResponse::mutable_step() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.LoggingResponse.step)
  return &step_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::LabeledStepStats >&
LoggingResponse::step() const {
  // @@protoc_insertion_point(field_list:tensorflow.LoggingResponse.step)
  return step_;
}

inline const LoggingResponse* LoggingResponse::internal_default_instance() {
  return &LoggingResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// TraceOpts

// optional double duration = 1;
inline void TraceOpts::clear_duration() {
  duration_ = 0;
}
inline double TraceOpts::duration() const {
  // @@protoc_insertion_point(field_get:tensorflow.TraceOpts.duration)
  return duration_;
}
inline void TraceOpts::set_duration(double value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TraceOpts.duration)
}

// optional bool use_step_profiler = 2;
inline void TraceOpts::clear_use_step_profiler() {
  use_step_profiler_ = false;
}
inline bool TraceOpts::use_step_profiler() const {
  // @@protoc_insertion_point(field_get:tensorflow.TraceOpts.use_step_profiler)
  return use_step_profiler_;
}
inline void TraceOpts::set_use_step_profiler(bool value) {
  
  use_step_profiler_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TraceOpts.use_step_profiler)
}

// optional bool use_kernel_profiler = 3;
inline void TraceOpts::clear_use_kernel_profiler() {
  use_kernel_profiler_ = false;
}
inline bool TraceOpts::use_kernel_profiler() const {
  // @@protoc_insertion_point(field_get:tensorflow.TraceOpts.use_kernel_profiler)
  return use_kernel_profiler_;
}
inline void TraceOpts::set_use_kernel_profiler(bool value) {
  
  use_kernel_profiler_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TraceOpts.use_kernel_profiler)
}

// optional bool use_extended_profiler = 4;
inline void TraceOpts::clear_use_extended_profiler() {
  use_extended_profiler_ = false;
}
inline bool TraceOpts::use_extended_profiler() const {
  // @@protoc_insertion_point(field_get:tensorflow.TraceOpts.use_extended_profiler)
  return use_extended_profiler_;
}
inline void TraceOpts::set_use_extended_profiler(bool value) {
  
  use_extended_profiler_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TraceOpts.use_extended_profiler)
}

// optional bool use_gpu_profiler = 5;
inline void TraceOpts::clear_use_gpu_profiler() {
  use_gpu_profiler_ = false;
}
inline bool TraceOpts::use_gpu_profiler() const {
  // @@protoc_insertion_point(field_get:tensorflow.TraceOpts.use_gpu_profiler)
  return use_gpu_profiler_;
}
inline void TraceOpts::set_use_gpu_profiler(bool value) {
  
  use_gpu_profiler_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TraceOpts.use_gpu_profiler)
}

// optional bool use_sample_profiler = 6;
inline void TraceOpts::clear_use_sample_profiler() {
  use_sample_profiler_ = false;
}
inline bool TraceOpts::use_sample_profiler() const {
  // @@protoc_insertion_point(field_get:tensorflow.TraceOpts.use_sample_profiler)
  return use_sample_profiler_;
}
inline void TraceOpts::set_use_sample_profiler(bool value) {
  
  use_sample_profiler_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TraceOpts.use_sample_profiler)
}

inline const TraceOpts* TraceOpts::internal_default_instance() {
  return &TraceOpts_default_instance_.get();
}
// -------------------------------------------------------------------

// TracingRequest

// optional .tensorflow.TraceOpts options = 1;
inline bool TracingRequest::has_options() const {
  return this != internal_default_instance() && options_ != NULL;
}
inline void TracingRequest::clear_options() {
  if (GetArenaNoVirtual() == NULL && options_ != NULL) delete options_;
  options_ = NULL;
}
inline const ::tensorflow::TraceOpts& TracingRequest::options() const {
  // @@protoc_insertion_point(field_get:tensorflow.TracingRequest.options)
  return options_ != NULL ? *options_
                         : *::tensorflow::TraceOpts::internal_default_instance();
}
inline ::tensorflow::TraceOpts* TracingRequest::mutable_options() {
  
  if (options_ == NULL) {
    _slow_mutable_options();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TracingRequest.options)
  return options_;
}
inline ::tensorflow::TraceOpts* TracingRequest::release_options() {
  // @@protoc_insertion_point(field_release:tensorflow.TracingRequest.options)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_options();
  } else {
    ::tensorflow::TraceOpts* temp = options_;
    options_ = NULL;
    return temp;
  }
}
inline  void TracingRequest::set_allocated_options(::tensorflow::TraceOpts* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options != NULL) {
    _slow_set_allocated_options(message_arena, &options);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TracingRequest.options)
}

inline const TracingRequest* TracingRequest::internal_default_instance() {
  return &TracingRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// TracingResponse

inline const TracingResponse* TracingResponse::internal_default_instance() {
  return &TracingResponse_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tensorflow_2fcore_2fprotobuf_2fworker_2eproto__INCLUDED
